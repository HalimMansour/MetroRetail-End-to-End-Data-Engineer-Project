
  
    USE [MetroRetailDB];
    USE [MetroRetailDB];
    
    

    

    
    USE [MetroRetailDB];
    EXEC('
        create view "Gold"."fact_sales__dbt_tmp__dbt_tmp_vw" as 

/*
    Gold Model: Sales Fact Table (TRANSACTION-LEVEL)
    Sources: 
    - Silver.pos_transactions_lines_clean (line items)
    - Silver.pos_transactions_header_clean (header)
    Target: Gold.fact_sales

    Transaction Fact Table
    Grain: One row per transaction line (Transaction_Line_ID)
    
    Fact Type: TRANSACTIONAL (records individual business events)
    Measures: ADDITIVE (can sum across all dimensions)
    
    Business Rules:
    - Join lines to header for transaction context
    - All amounts are ADDITIVE measures
    - Supports detailed sales analysis at line level
*/

WITH lines AS (
    SELECT *
    FROM "MetroRetailDB"."Silver"."pos_transactions_lines_clean"
    WHERE Is_Valid = 1
),

headers AS (
    SELECT *
    FROM "MetroRetailDB"."Silver"."pos_transactions_header_clean"
    WHERE Is_Valid = 1
),

-- Join lines with headers to get complete transaction context
sales_with_context AS (
    SELECT
        -- From Lines
        l.Transaction_Line_ID,
        l.Transaction_ID,
        l.Line_Number,
        l.Product_SKU,
        l.Store_ID,
        l.Quantity,
        l.Unit_Price,
        l.Cost_Price,
        l.Discount_Amount,
        l.Line_Sales_Amount,
        l.Promotion_ID,
        
        -- From Header
        h.Transaction_Date,
        h.Transaction_TS,
        h.Customer_ID,
        h.Payment_Method,
        
        -- Business Flags from Lines
        l.Is_Return,
        l.Is_Outlier_Quantity,
        l.Has_Discount,
        l.Has_Promotion,
        
        -- Business Flags from Header
        h.Is_Walk_In,
        
        -- DQ Scores (average for context)
        (l.DQ_Score + h.DQ_Score) / 2 AS Avg_DQ_Score
        
    FROM lines l
    INNER JOIN headers h ON l.Transaction_ID = h.Transaction_ID
    -- LEFT JOIN headers h ON l.Transaction_ID = h.Transaction_ID

),

final AS (
    SELECT
        -- Sales_Key will be auto-generated by SQL Server IDENTITY
        
        -- Degenerate Dimensions (transaction identifiers stored in fact)
        Transaction_Line_ID,
        Transaction_ID,
        Line_Number,
        
        -- Foreign Keys (natural keys for dimension joins)
        Transaction_Date,          -- FK to dim_date
        Product_SKU,               -- FK to dim_product
        Store_ID,                  -- FK to dim_store
        Customer_ID,               -- FK to dim_customer (nullable for walk-ins)
        COALESCE(Promotion_ID, ''N/A'') AS Promotion_ID,  -- FK to dim_promotion (nullable)
        
        -- Measures (ADDITIVE - can sum across all dimensions)
        Quantity,                  -- Can be negative (returns)
        Unit_Price,
        Cost_Price,
        Line_Sales_Amount,         -- Revenue
        COALESCE(Discount_Amount, 0) AS Discount_Amount,
        
        -- Derived Measures (calculated from base measures)
        CAST(Quantity AS DECIMAL(18,2)) * Cost_Price AS Line_Cost_Amount,
        Line_Sales_Amount - (CAST(Quantity AS DECIMAL(18,2)) * Cost_Price) AS Line_Margin_Amount,
        
        CASE 
            WHEN CAST(Quantity AS DECIMAL(18,2)) * Cost_Price > 0 
            THEN (Line_Sales_Amount - (CAST(Quantity AS DECIMAL(18,2)) * Cost_Price)) 
                 / (CAST(Quantity AS DECIMAL(18,2)) * Cost_Price) * 100
            ELSE 0 
        END AS Line_Margin_Pct,
        
        -- Context Attributes (semi-additive or non-additive)
        Payment_Method,
        Transaction_TS,
        
        -- Business Flags
        Is_Return,
        Is_Outlier_Quantity,
        Has_Discount,
        Has_Promotion,
        Is_Walk_In,
        
        -- Metadata
        CAST(Avg_DQ_Score AS INT) AS DQ_Score,
        GETDATE() AS Created_TS,
        GETDATE() AS Updated_TS
        
    FROM sales_with_context
)

SELECT * FROM final

/*
    Output Schema:
    - Sales_Key: INT - Surrogate key (auto-generated)
    
    Degenerate Dimensions:
    - Transaction_Line_ID: VARCHAR(50) - Business key
    - Transaction_ID: VARCHAR(50) - Parent transaction
    - Line_Number: INT - Line sequence
    
    Foreign Keys (Natural Keys):
    - Transaction_Date: DATE - FK to dim_date
    - Product_SKU: VARCHAR(50) - FK to dim_product
    - Store_ID: VARCHAR(50) - FK to dim_store
    - Customer_ID: VARCHAR(50) - FK to dim_customer (nullable)
    - Promotion_ID: VARCHAR(50) - FK to dim_promotion (nullable)
    
    Additive Measures:
    - Quantity: INT - Can be negative (returns)
    - Unit_Price: DECIMAL(18,2)
    - Cost_Price: DECIMAL(18,2)
    - Line_Sales_Amount: DECIMAL(18,2) - Revenue
    - Discount_Amount: DECIMAL(18,2)
    - Line_Cost_Amount: DECIMAL(18,2) - Calculated
    - Line_Margin_Amount: DECIMAL(18,2) - Calculated
    - Line_Margin_Pct: DECIMAL(18,2) - Calculated
    
    Context Attributes:
    - Payment_Method: VARCHAR(20)
    - Transaction_TS: DATETIME2
    
    Business Flags:
    - Is_Return: BIT
    - Is_Outlier_Quantity: BIT
    - Has_Discount: BIT
    - Has_Promotion: BIT
    - Is_Walk_In: BIT
    
    Metadata:
    - DQ_Score: INT
    - Created_TS: DATETIME2
    - Updated_TS: DATETIME2
    
    ═══════════════════════════════════════════════════════════
    GRAIN: One row per transaction line item
    ═══════════════════════════════════════════════════════════
    
    Analysis Examples:
    
    1. Total Sales by Date:
       SELECT 
           d.Date_Value,
           d.Day_Name,
           SUM(f.Line_Sales_Amount) AS Total_Sales,
           SUM(f.Line_Margin_Amount) AS Total_Margin,
           COUNT(DISTINCT f.Transaction_ID) AS Transaction_Count
       FROM fact_sales f
       INNER JOIN dim_date d ON f.Transaction_Date = d.Date_Value
       GROUP BY d.Date_Value, d.Day_Name
       ORDER BY d.Date_Value;
    
    2. Sales by Product Category:
       SELECT 
           p.Category,
           p.Sub_Category,
           SUM(f.Quantity) AS Units_Sold,
           SUM(f.Line_Sales_Amount) AS Total_Revenue,
           AVG(f.Line_Margin_Pct) AS Avg_Margin_Pct
       FROM fact_sales f
       INNER JOIN dim_product p ON f.Product_SKU = p.Product_SKU AND p.Is_Current = 1
       GROUP BY p.Category, p.Sub_Category
       ORDER BY Total_Revenue DESC;
    
    3. Store Performance:
       SELECT 
           s.Store_Name,
           s.Region,
           s.City,
           SUM(f.Line_Sales_Amount) AS Total_Sales,
           SUM(f.Line_Margin_Amount) AS Total_Margin,
           COUNT(DISTINCT f.Customer_ID) AS Unique_Customers,
           COUNT(DISTINCT f.Transaction_ID) AS Transaction_Count
       FROM fact_sales f
       INNER JOIN dim_store s ON f.Store_ID = s.Store_ID
       GROUP BY s.Store_Name, s.Region, s.City
       ORDER BY Total_Sales DESC;
    
    4. Customer Segmentation:
       SELECT 
           c.City,
           c.Preferred_Channel,
           COUNT(DISTINCT c.Customer_ID) AS Customer_Count,
           SUM(f.Line_Sales_Amount) AS Total_Spent,
           AVG(f.Line_Sales_Amount) AS Avg_Transaction_Value
       FROM fact_sales f
       INNER JOIN dim_customer c ON f.Customer_ID = c.Customer_ID
       WHERE f.Is_Walk_In = 0
       GROUP BY c.City, c.Preferred_Channel;
    
    5. Promotion Effectiveness:
       SELECT 
           p.Promo_Name,
           p.Promo_Type,
           COUNT(DISTINCT f.Transaction_ID) AS Transaction_Count,
           SUM(f.Line_Sales_Amount) AS Promo_Sales,
           SUM(f.Discount_Amount) AS Total_Discount,
           SUM(f.Line_Margin_Amount) AS Net_Margin
       FROM fact_sales f
       INNER JOIN dim_promotion p ON f.Promotion_ID = p.Promotion_ID
       WHERE f.Has_Promotion = 1
       GROUP BY p.Promo_Name, p.Promo_Type
       ORDER BY Promo_Sales DESC;
    
    6. Weather Impact on Sales:
       SELECT 
           w.Weather_Condition,
           w.Temperature_C,
           COUNT(DISTINCT f.Transaction_ID) AS Transaction_Count,
           SUM(f.Line_Sales_Amount) AS Total_Sales,
           AVG(f.Line_Sales_Amount) AS Avg_Line_Value
       FROM fact_sales f
       INNER JOIN dim_weather w ON f.Transaction_Date = w.Weather_Date 
                                 AND f.Store_ID = w.Store_ID
       INNER JOIN dim_date d ON f.Transaction_Date = d.Date_Value
       WHERE d.Year = 2024
       GROUP BY w.Weather_Condition, w.Temperature_C
       ORDER BY Total_Sales DESC;
    
    7. Returns Analysis:
       SELECT 
           d.Year_Month,
           p.Category,
           COUNT(*) AS Return_Count,
           SUM(f.Line_Sales_Amount) AS Return_Amount,
           SUM(f.Quantity) AS Return_Quantity
       FROM fact_sales f
       INNER JOIN dim_date d ON f.Transaction_Date = d.Date_Value
       INNER JOIN dim_product p ON f.Product_SKU = p.Product_SKU AND p.Is_Current = 1
       WHERE f.Is_Return = 1
       GROUP BY d.Year_Month, p.Category
       ORDER BY d.Year_Month, Return_Amount DESC;
*/;
    ')

EXEC('
            SELECT * INTO "MetroRetailDB"."Gold"."fact_sales__dbt_tmp" FROM "MetroRetailDB"."Gold"."fact_sales__dbt_tmp__dbt_tmp_vw" 
    OPTION (LABEL = ''dbt-sqlserver'');

        ')

    
    EXEC('DROP VIEW IF EXISTS Gold.fact_sales__dbt_tmp__dbt_tmp_vw')



    
    use [MetroRetailDB];
    if EXISTS (
        SELECT *
        FROM sys.indexes with (nolock)
        WHERE name = 'Gold_fact_sales__dbt_tmp_cci'
        AND object_id=object_id('Gold_fact_sales__dbt_tmp')
    )
    DROP index "Gold"."fact_sales__dbt_tmp".Gold_fact_sales__dbt_tmp_cci
    CREATE CLUSTERED COLUMNSTORE INDEX Gold_fact_sales__dbt_tmp_cci
    ON "Gold"."fact_sales__dbt_tmp"

   


  